<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Limpieza de transliteración (diccionario_unificado)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      max-width: 980px;
      margin: 2rem auto;
      padding: 0 1rem 2rem;
      line-height: 1.45;
    }
    h1 { margin-bottom: .2rem; }
    .muted { opacity: .8; margin-top: 0; }
    .card {
      border: 1px solid #8884;
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      background: #9991;
    }
    .row { display: flex; gap: .8rem; flex-wrap: wrap; align-items: center; }
    input[type="file"] { max-width: 100%; }
    button {
      border: 1px solid #8887;
      border-radius: 10px;
      padding: .6rem .9rem;
      font-weight: 600;
      cursor: pointer;
      background: #3f82ff22;
    }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    textarea {
      width: 100%;
      min-height: 160px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      border-radius: 10px;
      padding: .8rem;
      border: 1px solid #8886;
      background: #00000011;
    }
    code { background: #00000012; padding: .2rem .4rem; border-radius: 6px; }
    #log { white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Limpieza de transliteración (JSON en el mismo formato)</h1>
  <p class="muted">Herramienta <strong>100% cliente</strong> para GitHub Pages: carga <code>diccionario_unificado.min.json</code>, corrige transliteraciones usando <code>reglas.txt</code> y descarga un JSON nuevo sin cambiar la estructura.</p>

  <section class="card">
    <h2>1) Archivos de entrada</h2>
    <div class="row">
      <label>JSON: <input id="jsonFile" type="file" accept=".json,application/json" /></label>
      <label>Reglas (opcional): <input id="rulesFile" type="file" accept=".txt,text/plain" /></label>
    </div>
    <p>Si no subes reglas, se usarán las cargadas por defecto (las de <code>reglas.txt</code>).</p>
  </section>

  <section class="card">
    <h2>2) Reglas activas</h2>
    <textarea id="rulesText" spellcheck="false"></textarea>
  </section>

  <section class="card">
    <h2>3) Proceso y descarga</h2>
    <div class="row">
      <button id="processBtn">Corregir transliteraciones</button>
      <button id="downloadBtn" disabled>Descargar JSON limpio</button>
    </div>
    <p id="log">Esperando archivos...</p>
  </section>
 <section class="card">
    <h2>4) Criterio de acentuación (Archive.org)</h2>
    <p>Se aplicó una heurística para marcar tildes en transliteración según acento prosódico:</p>
    <ul>
      <li>Por defecto el acento hebreo va al final (<em>milrá</em>), salvo patrones con excepciones.</li>
            <li>Para <strong>ו</strong> se aplica regla contextual (gramáticas clásicas en Archive.org): <code>וֹ</code> funciona como mater lectionis (no suena como consonante), <code>וּ</code> se trata como /u/, y solo se mantiene consonántica cuando no actúa como soporte vocálico.</li>
      <li>Si hay <em>pataḥ furtivum</em> al final (por ejemplo en <code>רוּחַ</code>), el acento recae en la vocal anterior, por eso sale <code>rúaj</code>.</li>
      <li>La tilde solo se escribe cuando hace falta en ortografía española (no en todas las palabras).</li>
    </ul>
    <p class="muted">Fuentes consultadas en Archive.org: Gesenius, <em>Hebrew Grammar</em>; Davidson, <em>An Introductory Hebrew Grammar</em>; y Jouon, <em>A Grammar of Biblical Hebrew</em>.</p>
  </section>
  <script>
    const defaultRules = `א        '
ב        v
בּ       b
ג       g
ד       d
ה       h
ו       v
ז       z
ח      j
ט     t
י     y
כ     j
כּ     k
ל     l
מ     m
נ      n
ס     s
ע     '
פ     f
פּ     p
צ    tz
ק    q
ר    r
שׂ    s
שׁ    sh
ת    t
ך     j
ם     m
ן     n
ף    f
ץ   tz`;

   const cantillationRE = /[\u0591-\u05AF]/g;
        const metegRE = /\u05BD/;
    const hebrewLetterRE = /[\u05D0-\u05EA]/;
    const vowelMap = {
      '\u05B0': 'e', // sheva
      '\u05B1': 'e',
      '\u05B2': 'a',
      '\u05B3': 'o',
      '\u05B4': 'i',
      '\u05B5': 'e',
      '\u05B6': 'e',
      '\u05B7': 'a',
      '\u05B8': 'a',
      '\u05B9': 'o',
      '\u05BA': 'o',
      '\u05BB': 'u',
      '\u05C7': 'a'
    };
    const consonantMarks = new Set(['\u05BC', '\u05C1', '\u05C2']);
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const jsonFileEl = document.getElementById('jsonFile');
    const rulesFileEl = document.getElementById('rulesFile');
    const rulesTextEl = document.getElementById('rulesText');
    const logEl = document.getElementById('log');

    let cleanedData = null;
    rulesTextEl.value = defaultRules;

    const parseRules = (txt) => {
      const map = new Map();
      const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        const parts = line.split(/\s+/);
        if (parts.length < 2) continue;
        const heb = parts[0];
        const lat = parts[1];
        map.set(heb, lat);
      }
      return map;
    };

     const acuteMap = { a: 'á', e: 'é', i: 'í', o: 'ó', u: 'ú', A: 'Á', E: 'É', I: 'Í', O: 'Ó', U: 'Ú' };
    const latinVowelRE = /[aeiouáéíóú]/i;

      const shouldCarryAccent = (_word, _stressedFromEnd, syllables) => syllables > 1;
    const accentuateVowelAt = (word, vowelIndex) => {
      const vowels = [];
      for (let i = 0; i < word.length; i += 1) {
        if (latinVowelRE.test(word[i])) vowels.push(i);
      }
      if (vowelIndex < 0 || vowelIndex >= vowels.length) return word;
      const idx = vowels[vowelIndex];
      const ch = word[idx];
      if (!acuteMap[ch]) return word;
      return `${word.slice(0, idx)}${acuteMap[ch]}${word.slice(idx + 1)}`;
    };

        const normalizeTranslitCasing = (text) => text.toLowerCase();
    const applySpanishStressMark = (hebrew, translit) => {
      if (!translit) return translit;
      const plain = translit.normalize('NFC');
      const vowelOrder = [];
      for (let i = 0; i < plain.length; i += 1) {
        if (/[aeiou]/i.test(plain[i])) vowelOrder.push(i);
      }
      const syllables = vowelOrder.length;
      if (!syllables) return plain;

      const hasFurtivePatach = /[חעה]ַ\s*$/u.test(hebrew);
      const hasMeteg = metegRE.test(hebrew);
      const stressFromEnd = hasFurtivePatach || hasMeteg ? 2 : 1;
      const stressedVowelOrder = hasFurtivePatach || hasMeteg ? syllables - 2 : syllables - 1;

      if (!shouldCarryAccent(plain, stressFromEnd, syllables)) return plain;
      return accentuateVowelAt(plain, stressedVowelOrder);
    };
    const sortedRuleKeys = (map) => [...map.keys()].sort((a, b) => b.length - a.length);

     const splitClusters = (src) => {
      const clusters = [];
      for (let i = 0; i < src.length; i += 1) {
        const ch = src[i];
        if (!hebrewLetterRE.test(ch)) {
          clusters.push({ base: ch, marks: '' });
          continue;
        }
        let marks = '';
        while (i + 1 < src.length) {
          const next = src[i + 1];
          if (/^[\u0591-\u05C7]$/.test(next)) {
            marks += next;
            i += 1;
            continue;
          }
          break;
        }
        clusters.push({ base: ch, marks });
      }
      return clusters;
    };

    const hasLexicalVowel = (marks) => [...marks].some((m) => m in vowelMap && m !== '\u05B0');
    const shouldSoundSheva = (clusters, index) => {
      if (index <= 0 || index >= clusters.length) return false;
      const current = clusters[index];
      if (!current.marks.includes('\u05B0')) return false;

      const prev = clusters[index - 1];
      const next = clusters[index + 1];
      if (!prev || !next) return true;

      // Heurística práctica: si el shevá aparece tras vocal corta y antes
      // de una sílaba con vocal plena, suele funcionar como shevá naj (mudo).
      // Ejemplo clásico: אֶשְׁכֹּל -> eshkól (no eshekól).
      const prevHasShortVowel = [...prev.marks].some((m) => shortVowelMarks.has(m));
      if (prevHasShortVowel && hasLexicalVowel(next.marks)) return false;

      return true;
    };
    const transliterate = (hebrew, map, keys) => {
      if (!hebrew || typeof hebrew !== 'string') return '';
const src = hebrew.replace(cantillationRE, '');
      const clusters = splitClusters(src);
      let out = '';
       for (let i = 0; i < clusters.length; i += 1) {
        const { base, marks } = clusters[i];

        if (!hebrewLetterRE.test(base)) {
          if (/\s/.test(base)) out += ' ';
          continue;
        }

        const consonantOnlyMarks = [...marks].filter((m) => consonantMarks.has(m)).join('');
        const keyWithConsonantMarks = `${base}${consonantOnlyMarks}`;
        let consonant = map.get(keyWithConsonantMarks) ?? map.get(base) ?? '';

       // Reglas de ו (vav) basadas en gramáticas clásicas:
        // - וֹ (holam male): funciona como mater lectionis, no agrega consonante.
        // - וּ (shuruk): aporta /u/ como vocal.
        // - en otros casos conserva valor consonántico.
        if (base === 'ו') {
          if (marks.includes('ֹ') || marks.includes('ֺ')) {
            consonant = '';
          } else if (marks.includes('ּ') && ![...marks].some((m) => m in vowelMap)) {
            consonant = '';
          }
        }
      const isLastCluster = i === clusters.length - 1;
        let vowels = '';
        for (const mark of marks) {
          if (mark === '\u05B0' && !shouldSoundSheva(clusters, i)) continue;
          if (isLastCluster && mark === '\u05B0') continue;
          if (mark in vowelMap) {
            vowels += vowelMap[mark];
          }
        }

          if (isLastCluster && base === 'ך' && marks.includes('\u05B0')) {
          consonant = 'k';
        }
          if (base === 'ו' && marks.includes('ּ') && !vowels) {
          vowels = 'u';
        }
        const hasFurtivePatach = isLastCluster && /[חעה]/.test(base) && marks.includes('ַ');
        if (hasFurtivePatach) {
          out += vowels + consonant;
        } else {
          out += consonant + vowels;
        }
      }
 const normalized = out
   .replace(/\s+/g, ' ')
     // Corrige terminación dual hebrea defectiva: "aim" -> "ayim" (p. ej. Yerushalayim).
   .replace(/aim\b/gi, 'ayim')
   .replace(/ey(?=[^aeiouáéíóú]|$)/gi, 'ei')
        .replace(/''+/g, "'")
        .trim();
            return applySpanishStressMark(src, normalizeTranslitCasing(normalized));
    };

    const updateHeader = (header, lemma, translit) => {
      if (!header || typeof header !== 'string') return header;
      if (!lemma || typeof lemma !== 'string') return header;
      const escapedLemma = lemma.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const re = new RegExp(`^(.*${escapedLemma}\\s+)(\\S+)\\s*$`);
      if (re.test(header)) return header.replace(re, `$1${translit}`);
      return header;
    };

    const readTextFile = (file) => file.text();

    rulesFileEl.addEventListener('change', async () => {
      const f = rulesFileEl.files?.[0];
      if (!f) return;
      rulesTextEl.value = await readTextFile(f);
      logEl.textContent = 'Reglas cargadas desde archivo.';
    });

    processBtn.addEventListener('click', async () => {
      try {
        const jsonFile = jsonFileEl.files?.[0];
        if (!jsonFile) {
          logEl.textContent = '⚠️ Debes cargar un JSON primero.';
          return;
        }

        const raw = await readTextFile(jsonFile);
        const data = JSON.parse(raw);
        if (!Array.isArray(data)) {
          logEl.textContent = '⚠️ El JSON debe ser un arreglo de entradas.';
          return;
        }

        const map = parseRules(rulesTextEl.value || defaultRules);
        const keys = sortedRuleKeys(map);

        let changed = 0;
        let missingLemma = 0;

        const cleaned = data.map((entry) => {
          if (!entry || typeof entry !== 'object') return entry;
          const sd = entry.strong_detail;
          if (!sd || typeof sd !== 'object') return entry;

          const lemma = sd.lemma;
          if (!lemma) {
            missingLemma += 1;
            return entry;
          }

          const newT = transliterate(lemma, map, keys);
          const oldT = typeof sd.transliteracion === 'string' ? sd.transliteracion.trim() : '';

          if (newT && newT !== oldT) {
            changed += 1;
            const next = {
              ...entry,
              strong_detail: {
                ...sd,
                transliteracion: newT,
                header: updateHeader(sd.header, lemma, newT)
              }
            };
            return next;
          }

          return entry;
        });

        cleanedData = cleaned;
        downloadBtn.disabled = false;
        logEl.textContent = [
          `Entradas leídas: ${data.length}`,
          `Transliteraciones corregidas: ${changed}`,
          `Entradas sin lemma: ${missingLemma}`,
          'Listo para descargar el JSON limpio.'
        ].join('\n');
      } catch (err) {
        console.error(err);
        logEl.textContent = `❌ Error: ${err?.message || String(err)}`;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!cleanedData) return;
      const blob = new Blob([JSON.stringify(cleanedData)], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'diccionario_unificado.limpio.min.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
