<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Limpieza de transliteración (diccionario_unificado)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      max-width: 980px;
      margin: 2rem auto;
      padding: 0 1rem 2rem;
      line-height: 1.45;
    }
    h1 { margin-bottom: .2rem; }
    .muted { opacity: .8; margin-top: 0; }
    .card {
      border: 1px solid #8884;
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
      background: #9991;
    }
    .row { display: flex; gap: .8rem; flex-wrap: wrap; align-items: center; }
    input[type="file"] { max-width: 100%; }
    button {
      border: 1px solid #8887;
      border-radius: 10px;
      padding: .6rem .9rem;
      font-weight: 600;
      cursor: pointer;
      background: #3f82ff22;
    }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    textarea {
      width: 100%;
      min-height: 160px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      border-radius: 10px;
      padding: .8rem;
      border: 1px solid #8886;
      background: #00000011;
    }
    code { background: #00000012; padding: .2rem .4rem; border-radius: 6px; }
    #log { white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Limpieza de transliteración (JSON en el mismo formato)</h1>
  <p class="muted">Herramienta <strong>100% cliente</strong> para GitHub Pages: carga <code>diccionario_unificado.min.json</code>, corrige transliteraciones usando <code>reglas.txt</code> y descarga un JSON nuevo sin cambiar la estructura.</p>

  <section class="card">
    <h2>1) Archivos de entrada</h2>
    <div class="row">
      <label>JSON: <input id="jsonFile" type="file" accept=".json,application/json" /></label>
      <label>Reglas (opcional): <input id="rulesFile" type="file" accept=".txt,text/plain" /></label>
    </div>
    <p>Si no subes reglas, se usarán las cargadas por defecto (las de <code>reglas.txt</code>).</p>
  </section>

  <section class="card">
    <h2>2) Reglas activas</h2>
    <textarea id="rulesText" spellcheck="false"></textarea>
  </section>

  <section class="card">
    <h2>3) Proceso y descarga</h2>
    <div class="row">
      <button id="processBtn">Corregir transliteraciones</button>
      <button id="downloadBtn" disabled>Descargar JSON limpio</button>
    </div>
    <p id="log">Esperando archivos...</p>
  </section>

  <script>
    const defaultRules = `א        '
ב        v
בּ       b
ג       g
ד       d
ה       h
ו       v
ז       z
ח      j
ט     t
י     y
כ     j
כּ     k
ל     L
מ     m
נ      n
ס     s
ע     '
פ     f
פּ     p
צ    tz
ק    q
ר    r
שׂ    s
שׁ    sh
ת    t
ך     j
ם     m
ן     n
ף    f
ץ   tz`;

   const cantillationRE = /[\u0591-\u05AF]/g;
    const hebrewLetterRE = /[\u05D0-\u05EA]/;
    const vowelMap = {
      '\u05B0': 'e', // sheva
      '\u05B1': 'e',
      '\u05B2': 'a',
      '\u05B3': 'o',
      '\u05B4': 'i',
      '\u05B5': 'e',
      '\u05B6': 'e',
      '\u05B7': 'a',
      '\u05B8': 'a',
      '\u05B9': 'o',
      '\u05BA': 'o',
      '\u05BB': 'u',
      '\u05C7': 'a'
    };
    const consonantMarks = new Set(['\u05BC', '\u05C1', '\u05C2']);
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const jsonFileEl = document.getElementById('jsonFile');
    const rulesFileEl = document.getElementById('rulesFile');
    const rulesTextEl = document.getElementById('rulesText');
    const logEl = document.getElementById('log');

    let cleanedData = null;
    rulesTextEl.value = defaultRules;

    const parseRules = (txt) => {
      const map = new Map();
      const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        const parts = line.split(/\s+/);
        if (parts.length < 2) continue;
        const heb = parts[0];
        const lat = parts[1];
        map.set(heb, lat);
      }
      return map;
    };

    const sortedRuleKeys = (map) => [...map.keys()].sort((a, b) => b.length - a.length);

     const splitClusters = (src) => {
      const clusters = [];
      for (let i = 0; i < src.length; i += 1) {
        const ch = src[i];
        if (!hebrewLetterRE.test(ch)) {
          clusters.push({ base: ch, marks: '' });
          continue;
        }
        let marks = '';
        while (i + 1 < src.length) {
          const next = src[i + 1];
          if (/^[\u0591-\u05C7]$/.test(next)) {
            marks += next;
            i += 1;
            continue;
          }
          break;
        }
        clusters.push({ base: ch, marks });
      }
      return clusters;
    };
    const transliterate = (hebrew, map, keys) => {
      if (!hebrew || typeof hebrew !== 'string') return '';
const src = hebrew.replace(cantillationRE, '');
      const clusters = splitClusters(src);
      let out = '';
       for (let i = 0; i < clusters.length; i += 1) {
        const { base, marks } = clusters[i];

        if (!hebrewLetterRE.test(base)) {
          if (/\s/.test(base)) out += ' ';
          continue;
        }

        const consonantOnlyMarks = [...marks].filter((m) => consonantMarks.has(m)).join('');
        const keyWithConsonantMarks = `${base}${consonantOnlyMarks}`;
        let consonant = map.get(keyWithConsonantMarks) ?? map.get(base) ?? '';

        // Heurística: ו entre consonantes suele ser vocal (ruaj, shul, etc.).
        if (base === 'ו' && ![...marks].some((m) => m in vowelMap)) {
          const prev = clusters[i - 1];
          const next = clusters[i + 1];
          if (prev?.base && hebrewLetterRE.test(prev.base) && next?.base && hebrewLetterRE.test(next.base)) {
            consonant = 'u';
          }
        }
       let vowels = '';
        for (const mark of marks) {
          if (mark in vowelMap) {
            vowels += vowelMap[mark];
          }
        }

        const isLastCluster = i === clusters.length - 1;
        const hasFurtivePatach = isLastCluster && /[חעה]/.test(base) && marks.includes('ַ');
        if (hasFurtivePatach) {
          out += vowels + consonant;
        } else {
          out += consonant + vowels;
        }
      }
      return out
        .replace(/\s+/g, ' ')
        .replace(/''+/g, "'")
        .trim();
    };

    const updateHeader = (header, lemma, translit) => {
      if (!header || typeof header !== 'string') return header;
      if (!lemma || typeof lemma !== 'string') return header;
      const escapedLemma = lemma.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const re = new RegExp(`^(.*${escapedLemma}\\s+)(\\S+)\\s*$`);
      if (re.test(header)) return header.replace(re, `$1${translit}`);
      return header;
    };

    const readTextFile = (file) => file.text();

    rulesFileEl.addEventListener('change', async () => {
      const f = rulesFileEl.files?.[0];
      if (!f) return;
      rulesTextEl.value = await readTextFile(f);
      logEl.textContent = 'Reglas cargadas desde archivo.';
    });

    processBtn.addEventListener('click', async () => {
      try {
        const jsonFile = jsonFileEl.files?.[0];
        if (!jsonFile) {
          logEl.textContent = '⚠️ Debes cargar un JSON primero.';
          return;
        }

        const raw = await readTextFile(jsonFile);
        const data = JSON.parse(raw);
        if (!Array.isArray(data)) {
          logEl.textContent = '⚠️ El JSON debe ser un arreglo de entradas.';
          return;
        }

        const map = parseRules(rulesTextEl.value || defaultRules);
        const keys = sortedRuleKeys(map);

        let changed = 0;
        let missingLemma = 0;

        const cleaned = data.map((entry) => {
          if (!entry || typeof entry !== 'object') return entry;
          const sd = entry.strong_detail;
          if (!sd || typeof sd !== 'object') return entry;

          const lemma = sd.lemma;
          if (!lemma) {
            missingLemma += 1;
            return entry;
          }

          const newT = transliterate(lemma, map, keys);
          const oldT = typeof sd.transliteracion === 'string' ? sd.transliteracion.trim() : '';

          if (newT && newT !== oldT) {
            changed += 1;
            const next = {
              ...entry,
              strong_detail: {
                ...sd,
                transliteracion: newT,
                header: updateHeader(sd.header, lemma, newT)
              }
            };
            return next;
          }

          return entry;
        });

        cleanedData = cleaned;
        downloadBtn.disabled = false;
        logEl.textContent = [
          `Entradas leídas: ${data.length}`,
          `Transliteraciones corregidas: ${changed}`,
          `Entradas sin lemma: ${missingLemma}`,
          'Listo para descargar el JSON limpio.'
        ].join('\n');
      } catch (err) {
        console.error(err);
        logEl.textContent = `❌ Error: ${err?.message || String(err)}`;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!cleanedData) return;
      const blob = new Blob([JSON.stringify(cleanedData)], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'diccionario_unificado.limpio.min.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
